Describing objects
==================
In Dogmatist, you describe objects using a simple fluent syntax. This
descriptive method results in a ``Builder`` object being created. Feeding this
``Builder`` into the sampler will allow Dogmatist to create an instance of that
object.

Starting a description
----------------------

To start an object description, use the ``create()`` method on the ``Dogmatist``
instance, like so for creating a description for an array:

.. code-block:: php

    // $dogmatist is an instance of ``Dogmatist``
    $builder = $dogmatist->create('array');

The first (and only) argument of the ``create()`` method specifies the type of
object that should be created. You can specify the type as follows:

* Using ``array``. This will not create an object, but a native PHP array
  instead.
* Using ``object`` (or ``stdClass``): this will cast the array as previously
  specified to an object, and thus will return an instance of ``stdClass``.
* Using a fully namespaced class name. Note that the class name needs to be
  loadable using some sort of autoloader and that it should be possible to
  create an instance. Dogmatist does not work with interfaces, traits or
  abstract classes, only concrete (or final) classes can be used.


.. note:: This documentation often uses the PHP 5.5+ syntax of ``::class``. This
          syntax allows you to get the full namespaced classname when all you
          have is an imported symbol name of some class. This prevents having to
          write down the class name as a string, which is error-prone and does
          not allow for easy refactoring.

Say we have a Doctrine2 ORM entity in our project called ``Acme\Entity\Person``
then we might for example use this to create a builder for that class:

.. code-block:: php

    use Acme\Entity\Person;

    $builder = $dogmatist->create(Person::class);

Describing fields
-----------------
Once a Builder instance is retrieved using the create method you have several
methods to describe the fields contained in that class. The methods available
are described below:

``none($field)``
    A field described using this method will ensure that the field will never
    be touched when sampling. By default all fields in an object won't be
    touched. So this method is mainly used to remove fields which have
    previously been added.

``fake($field, $type[, $options])``
    The fake method is used to describe a field in your object which should get
    some random value generated by Faker_. The type should be a type that is
    available in the ``Faker\Generator`` instance that Dogmatist has. You can
    use one of the default providers Faker_ provides, such as ``randomNumber``
    or ``country``, or you can create your own Providers and register them in
    the Generator instance to have more ways of specifying field values.

    Note that you can specify an array of options that should be passed on to
    the generator. If you were to call a faker method directly these would
    normally be the arguments entered here.

``select($field, $options)``
    The select field allows you to specify that a random value from a list of
    predetermined values should be picked. Note that this is equivalent to using
    ``fake($field, 'randomElement', [$options])``, however since select fields
    may occur quite often (such as in the case of Male/Female or true/false)
    they have been given a special descriptive function.

``value($field, $value)``
    Set a predetermined value for a specific field. This means that all samples
    of the object will always have the same value for a specific field. You can
    for example use this when describing something like an active user, where
    that active flag is indicated using a boolean which should always be true
    for active users.

``link($field, $value)``
    You can link one builder to another builder using this method. For a better
    description you should take a look at the section on saved builders.

``relation($field, $type)``
    This is the most complicated of all the available functions. The relation
    type of description allows you to describe a sub-builder for that specific
    property. For example take some User class which contains an Address.

.. _Faker: https://github.com/fzaninotto/Faker
